package main

import (
	"crypto/rand"
	"fmt"
	"sync"
	"testing"
	"time"
)

func TestWallet(t *testing.T) {
	// Create a new wallet
	name := "TestWallet"
	tags := []string{"tag1", "tag2"}
	wallet, err := NewWallet(name, tags)
	if err != nil {
		t.Fatalf("Failed to create wallet: %v", err)
	}

	// Verify wallet properties
	if wallet.Name != name {
		t.Errorf("Expected wallet name '%s', got '%s'", name, wallet.Name)
	}

	if len(wallet.Tags) != len(tags) {
		t.Errorf("Expected %d tags, got %d", len(tags), len(wallet.Tags))
	} else {
		for i := range tags {
			if wallet.Tags[i] != tags[i] {
				t.Errorf("Expected tag '%s', got '%s'", tags[i], wallet.Tags[i])
			}
		}
	}

	// Verify wallet address generation
	address := wallet.GetAddress()
	if address == "" {
		t.Error("Failed to generate wallet address")
	}

	// Encrypt and decrypt private key
	passphrase := "test passphrase"
	err = wallet.EncryptPrivateKey(passphrase)
	if err != nil {
		t.Fatalf("Failed to encrypt private key: %v", err)
	}

	err = wallet.DecryptPrivateKey(passphrase)
	if err != nil {
		t.Fatalf("Failed to decrypt private key: %v", err)
	}
}

func TestBankTransaction(t *testing.T) {
	// Create sender and receiver wallets
	sender, _ := NewWallet("Sender", nil)
	receiver, _ := NewWallet("Receiver", nil)

	// Create a bank transaction
	amount := 100.0
	bankTx, err := NewBankTransaction(sender, receiver, amount)
	if err != nil {
		t.Fatalf("Failed to create bank transaction: %v", err)
	}

	// Verify transaction properties
	if bankTx.From != sender {
		t.Errorf("Expected sender wallet %v, got %v", sender, bankTx.From)
	}

	if bankTx.To != receiver {
		t.Errorf("Expected receiver wallet %v, got %v", receiver, bankTx.To)
	}

	if bankTx.Amount != amount {
		t.Errorf("Expected amount %f, got %f", amount, bankTx.Amount)
	}

	// Verify transaction processing
	result := bankTx.Process()
	expectedResult := "Transferred 100.000000 from " + sender.Address + " to " + receiver.Address
	if result != expectedResult {
		t.Errorf("Expected process result '%s', got '%s'", expectedResult, result)
	}
}

func TestMessageTransaction(t *testing.T) {
	// Create sender and receiver wallets
	sender, _ := NewWallet("Sender", nil)
	receiver, _ := NewWallet("Receiver", nil)

	// Create a message transaction
	message := "Test message"
	msgTx, err := NewMessageTransaction(sender, receiver, message)
	if err != nil {
		t.Fatalf("Failed to create message transaction: %v", err)
	}

	// Verify transaction properties
	if msgTx.From != sender {
		t.Errorf("Expected sender wallet %v, got %v", sender, msgTx.From)
	}

	if msgTx.To != receiver {
		t.Errorf("Expected receiver wallet %v, got %v", receiver, msgTx.To)
	}

	if msgTx.Message != message {
		t.Errorf("Expected message '%s', got '%s'", message, msgTx.Message)
	}

	// Verify transaction processing
	result := msgTx.Process()
	expectedResult := "Message from " + sender.Address + " to " + receiver.Address + ": " + message
	if result != expectedResult {
		t.Errorf("Expected process result '%s', got '%s'", expectedResult, result)
	}
}

func TestBlockchain(t *testing.T) {
	// Create a new blockchain
	bc := NewBlockchain()

	// Create a wait group to wait for goroutines to finish
	var wg sync.WaitGroup

	// Start the blockchain in a separate goroutine
	wg.Add(1)
	go func() {
		defer wg.Done()
		bc.Run(1)
	}()

	// Create five wallets
	wallets := make([]*Wallet, 5)
	for i := range wallets {
		wallet, _ := NewWallet(fmt.Sprintf("Wallet%d", i+1), nil)
		wallets[i] = wallet
		bc.AddWallet(wallet)
	}

	// Perform 100 random transactions over a 20-second period
	for i := 0; i < 100; i++ {
		// Select a random sender and receiver
		sender := wallets[rand.Intn(len(wallets))]
		receiver := wallets[rand.Intn(len(wallets))]
		for receiver == sender {
			receiver = wallets[rand.Intn(len(wallets))]
		}

		// Create a random amount for the transaction
		amount := float64(rand.Intn(100) + 1)

		// Create a bank transaction
		bankTx, err := NewBankTransaction(sender, receiver, amount)
		if err != nil {
			t.Fatalf("Failed to create bank transaction: %v", err)
		}

		// Add the transaction to the blockchain
		bc.AddTransaction(bankTx)

		// Create a message transaction
		message := fmt.Sprintf("Thanks for the money %d!", i)
		msgTx, err := NewMessageTransaction(receiver, sender, message)
		if err != nil {
			t.Fatalf("Failed to create message transaction: %v", err)
		}

		// Add the transaction to the blockchain
		bc.AddTransaction(msgTx)

		// Wait for a random duration between 0 and 200 milliseconds
		time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
	}

	// Wait for 20 seconds to allow blocks to be mined
	time.Sleep(20 * time.Second)

	// Verify that the blockchain contains at least one block
	if len(bc.Blocks) == 0 {
		t.Errorf("No blocks have been mined after 20 seconds")
	}

	// Stop the blockchain by closing the done channel
	bc.Stop()

	// Wait for the blockchain goroutine to finish
	wg.Wait()
}
